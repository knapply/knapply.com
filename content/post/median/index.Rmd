---
title: Median
author: Brendan Knapp
date: '2018-11-12'
slug: index
categories:
  - data-science-from-scratch
  - statistics
  - central-tendency
  - tutorial
  - programming
tags:
  - data-science-from-scratch
  - statistics
  - programming
  - r
  - python
  - rcpp
image:
  caption: ''
  focal_point: 'Smart'
summary: 'Finding median of a sequence, from scratch.'
output:
  blogdown::html_page:
    toc: true
    toc_depth: 5
citation_url: https://knapply.com/post/median/
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE, comment = "#>")

options(width=90)

source(here::here("static/R/html-helpers.R"))
source(here::here("static/R/citation.R"))
```



<!-- start topic -->
<!-- ----------- -->

<!-- # R -->

<!-- ## A Way -->

<!-- ```{r} -->


<!-- ``` -->

<!-- ## A Better Way -->

<!-- ```{r} -->

<!-- ``` -->


<!-- # Rcpp -->

<!-- ## A Way -->

<!-- ```{Rcpp, eval=FALSE} -->

<!-- ``` -->

<!-- ```{r} -->

<!-- ``` -->


<!-- ## A Better Way -->

<!-- ```{Rcpp} -->

<!-- ``` -->


<!-- ```{r} -->

<!-- ``` -->


<!-- # Python -->

<!-- ## A Way -->

<!-- ```{python} -->

<!-- ``` -->

<!-- ## A Better Way -->

<!-- ```{python} -->

<!-- ``` -->

<!-- ## NumPy -->

<!-- ```{python} -->

<!-- ``` -->

<!-- _________ -->
<!-- end topic -->



# What is it?

Given a sequence, which is the middle-most value. Put another way, what value is equally likely to be greater than the first half of a sorted sequence and lesser than the second half of a sorted sequence.

* Steps
  + sort the sequence
  + if the length of the sequence is odd
      + the middle value is the median
  + if length of the sequence is even
      + the mean of the 2 middle values is the median


# Walkthrough {.tabset .tabset-fade .tabset-pills}

# R

## Example Data

```{r}
r_even_n <- c(126, 793, 999, 525, 851, 798, 120, 714, 852, 151,
              190, 41, 612, 826, 507, 105, 14, 237, 669, 7)

r_odd_n <- c(126, 793, 999, 525, 851, 798, 120, 714, 852, 151,
             190, 41, 612, 826, 507, 105, 14, 237, 669, 7, 375)
```


## `stats::median()`

```{r}
c(median(r_even_n), median(r_odd_n))
```

## Step by Step

### Naïve

```{r}
r_naive_median <- function(x) {
  n <- length(x)                      # find `x`'s length
  sorted <- sort(x)                   # sort the values
  if (n %% 2L) {                      # `2L` marks `2` as begin an integer: if `n` is...
    out <- sorted[[n %/% 2L + 1L]]    # ... is odd, the median is the middle value...
                                      # ... `%/%` indicates integer division
  } else {                            # if `n` is even...
    mid1 <- sorted[[n %/% 2L]]        # ... take the first middle value...
    mid2 <- sorted[[n %/% 2L + 1L]]   # ... and second middle value...
    out <- mean(c(mid1, mid2))        # ... and calculate their mean
  }
  out                                 # return `out`
}

c(r_naive_median(r_even_n),
  r_naive_median(r_odd_n))
```

### Optimized

In R, we can target an index on which to pivot. We can find the median without needing to sort the entire sequence.

```{r}
r_fast_median <- function(x) {
  n <- length(x)                                       # find `x`'s length
  mid <- (n + 1L) %/% 2L                               # find index of mid-point
  partially_sorted <- sort(x, partial = n %/% 2L + 1L) # partially sort, targeting mid point
  if (n %% 2) {                                        # if `n` is odd...
    return(partially_sorted[mid])                      # ... the result is the mid point
  }      
                                                 # if `n` is even, subset the middle 2 ...
  mean(partially_sorted[c(mid, mid + 1L)])       # ... values and the result is their mean
}

c(r_fast_median(r_even_n),
  r_fast_median(r_odd_n))
```


# Rcpp

```{Rcpp, ref.label=knitr::all_rcpp_labels(), include=FALSE}
```

__Note:__ `Rcpp` examples assume code is prefaced with...

```{Rcpp, eval=FALSE}
#include <Rcpp.h>
using namespace Rcpp;
```

## Example Data

```{r}
r_even_n <- c(126, 793, 999, 525, 851, 798, 120, 714, 852, 151,
              190, 41, 612, 826, 507, 105, 14, 237, 669, 7)

r_odd_n <- c(126, 793, 999, 525, 851, 798, 120, 714, 852, 151,
             190, 41, 612, 826, 507, 105, 14, 237, 669, 7, 375)
```

## `Rcpp::median()`

```{Rcpp, eval=FALSE}
// [[Rcpp::export]]
double rcpp_sugar_median(NumericVector x) {
  return median(x);
}
```

```{r}
c(rcpp_sugar_median(r_even_n),
  rcpp_sugar_median(r_odd_n))
```

## Step by Step

### Naïve

```{Rcpp, eval=FALSE}
// [[Rcpp::export]]
double cpp_naive_median(NumericVector x) {
  int n = x.size();                 // find `x`'s length
  x.sort();                         // sort the values

  double out;                       // declare the variable to return
  if (n % 2) {                      // if `n` is odd...
    out = x[n / 2];                 // ... the median is the middle value
  } else {                          // if `n` is even...
    double mid1 = x[n / 2 - 1];     // ... take the first middle value...
    double mid2 = x[n / 2];         // ... and second middle value...
    out = (mid1 + mid2) / 2.0;      // ... and calculate their mean
  }

  return out;
}
```

```{r}
c(cpp_naive_median(r_even_n),
  cpp_naive_median(r_odd_n))
```



### Optimized

Rather than `sort()`ing the entire sequence, we can use [`std::nth_elemnt()`](https://en.cppreference.com/w/cpp/algorithm/nth_element), a built-in [quickselect](https://en.wikipedia.org/wiki/Quickselect) from `<algorithm>`.


```{Rcpp, eval=FALSE}
// [[Rcpp::export]]
double cpp_fast_median(NumericVector x) {
  int n = x.size();                            // find `x`'s length
  NumericVector::iterator start = x.begin();   // initialize iterator pointing to `x[0]`
  NumericVector::iterator mid = start + n / 2; // initialize iterator pointing to midpoint

  std::nth_element(start, mid, x.end());       // partially sort `x` so all values...
                                               // ... before `mid` are less than it...
                                               // ... and values after are greater than it
  if (n % 2) {                                 // if `n` is odd...
    return *mid;                               // return `mid`'s value by dereferencing...
  }                                            // ...the iterator with `*`

  double mid1 = *mid;                          // if even, hold `mid`
  std::nth_element( start, --mid, x.end() );   // partially sort again, decrementing...
                                               // ... `mid` to target `x[mid - 1]`
  return ( mid1 + *mid ) / 2.0;                // return their mean
}
```


```{r}
c(cpp_fast_median(r_even_n),
  cpp_fast_median(r_odd_n))
```

# Python

## Example Data

```{python}
py_even_n = [126, 793, 999, 525, 851, 798, 120, 714, 852, 151,
             190, 41, 612, 826, 507, 105, 14, 237, 669, 7]

py_odd_n = [126, 793, 999, 525, 851, 798, 120, 714, 852, 151,
            190, 41, 612, 826, 507, 105, 14, 237, 669, 7, 375]
```

## `statistics.median()`

Python's `statistics` module is part of its standard library; it come with Python.

```{python}
import statistics as stats

res1 = stats.median(py_even_n)
res2 = stats.median(py_odd_n)

print([res1, res2])
```

## `numpy.median()`

When available, prefer using `numpy`.

```{python}
import numpy as np

numpy_even_n = np.array(py_even_n)
numpy_odd_n = np.array(py_odd_n)

res1 = np.median(numpy_even_n)
res2 = np.median(numpy_odd_n)

print([res1, res2])
```

## Step by Step

### Naïve

```{python}
def py_median(x):
  n = len(x)
  sorted_x = sorted(x)
  if n % 2:
    return sorted_x[n // 2]
  mid1, mid2 = sorted_x[n // 2 - 1], sorted_x[n // 2]
  return (mid1 + mid2) / 2
  
res1 = py_median(py_even_n)
res2 = py_median(py_odd_n)

print([res1, res2])
```


# Shootout

```{r}
library(reticulate)
```


## Test Data

```{r}
set.seed(831)
big_dbl <- sample(sample(seq(1, 1e4, by = 0.2), replace = TRUE))

cat(paste0(head(big_dbl, 5), collapse = ", "), " ... ", 
    paste0(tail(big_dbl, 5), collapse = ", "),  "\n\n",
    "\tn = ", scales::comma(length(big_dbl)), "\n",
    "\tfootprint = ", capture.output(pryr::object_size(big_dbl)), sep = "")
```

```{python}
py_big_dbl = r.big_dbl
numpy_big_dbl = np.array(py_big_dbl.copy())
```

### Pre-Test Data Validatation

```{r}
all.equal(
  big_dbl,
  py$py_big_dbl,
  py$numpy_big_dbl
)
```


## Benchmarks

```{r}
library(bench)

res <- mark(
  median.default(big_dbl),
  r_naive_median(big_dbl),
  r_fast_median(big_dbl),
  rcpp_sugar_median(big_dbl),
  cpp_naive_median(big_dbl),
  cpp_fast_median(big_dbl),
  py_run_string("stats.median(py_big_dbl)", convert = FALSE),
  py_run_string("np.median(numpy_big_dbl)", convert = FALSE),
  py_run_string("py_median(numpy_big_dbl)", convert = FALSE),
  iterations = 50, check = FALSE, filter_gc = FALSE
)
```

```{r, echo=FALSE, fig.align='center', fig.width=9, fig.height=11, message=FALSE, warning=FALSE}
library(tidyverse)

res %>% 
  mutate(expression = as.character(expression)) %>% 
  mutate(type = recode(
    expression,
    "median.default(big_dbl)" = "R's built-in",
    "r_naive_median(big_dbl)" = "Naïve R",
    "r_fast_median(big_dbl)" = "Optimized R",
    "rcpp_sugar_median(big_dbl)" = "Rcpp's built-in",
    "cpp_naive_median(big_dbl)" = "Naïve Rcpp",
    "cpp_fast_median(big_dbl)" = "Optimized Rcpp",
    'py_run_string("stats.median(py_big_dbl)", convert = FALSE)' = "Python's built-in",
    'py_run_string("np.median(numpy_big_dbl)", convert = FALSE)' = "NumPy",
    'py_run_string("py_median(numpy_big_dbl)", convert = FALSE)' = "Naïve Python"
  )) %>%  
  mutate(expression = recode(
    expression,
    'py_run_string("stats.median(py_big_dbl)", convert = FALSE)' = 'stats.median(py_big_dbl)',
    'py_run_string("np.median(numpy_big_dbl)", convert = FALSE)' = 'np.median(numpy_big_dbl)',
    'py_run_string("py_median(numpy_big_dbl)", convert = FALSE)' = 'py_median(numpy_big_dbl)'
  )) %>% 
  unnest() %>% 
  group_by(type) %>% 
  mutate(mini = min(as.numeric(time))) %>% 
  ungroup() %>% 
  arrange(desc(mini)) %>% 
  mutate(type = as_factor(type)) %>% 
  arrange(mini) %>% 
  mutate(expression = as_factor(expression)) %>% 
  ggplot(aes(x = type, y = time, color = expression)) +
  ggbeeswarm::geom_beeswarm(cex = 0.65) +
  guides(color = guide_legend(ncol = 2, override.aes = list(size = 3))) +
  coord_flip() +
  theme_minimal(base_size = 16, base_family = "serif") +
  theme(axis.title = element_blank(),
        legend.position = "bottom", legend.title = element_blank(),
        legend.text = element_text(family = "mono"),
        plot.title = element_text(face = "bold.italic")) +
  labs(title = "Median Benchmark Shootout")
```

## Validate Results

```{r}
all.equal(
  median(big_dbl),
  r_naive_median(big_dbl),
  r_fast_median(big_dbl),
  rcpp_sugar_median(big_dbl),
  cpp_naive_median(big_dbl),
  cpp_fast_median(big_dbl),
  py$stats$median(py$py_big_dbl),
  py$np$median(py$numpy_big_dbl)
)
```

## Post-Test Data Validatation


```{r}
all.equal(
  big_dbl,
  py$py_big_dbl,
  py$numpy_big_dbl
)
```

## Environment

<details>
<summary> R </summary>
<p>

```{r}
sessionInfo()
```

</p>
</details>


<details>
<summary> C++ </summary>
<p>

```{r}
system("gcc --version", intern = TRUE)[[1]]
```

</p>
</details>


<details>
<summary> Python </summary>
<p>

```{python}
import sys

print(sys.version)
print(np.__version__)
```

</p>
</details>

<details>
<summary> CPU </summary>
<p>


```{r}
cat(system("wmic cpu get name", intern = TRUE)[[2]])
```

</p>
</details>


<details>
<summary> Memory </summary>
<p>

```{r}
system("wmic MEMORYCHIP get BankLabel, Capacity, Speed", intern = TRUE) %>% 
  str_trim() %>% 
  as_tibble() %>% 
  slice(2:3) %>% 
  separate(value, into = c("BankLabel", "Capacity", "Speed"), sep = "\\s{2,}") %>% 
  mutate_at(vars(Capacity), ~ paste(round(as.numeric(.) / 1e9, 2), "GB")) %>% 
  mutate(Speed = paste(Speed, "MHz")) %>% 
  rename_all(str_replace, "L", " L") %>% 
  knitr::kable(format = "html") %>% 
  kableExtra::kable_styling(full_width = FALSE)
```

</p>
</details>


<br><br><br>

```{r, echo=FALSE, comment=NA, results='markup'}
print_citation_header()
```

```{r, echo=FALSE, comment=NA, results='markup', class.output='citation'}
print_citation()
print_bibtex()
```



